using System;

namespace Lesson4_封装_构造函数和析构函数
{
    #region 知识点一 构造函数
    //基本函数
    //在实例化对象时 会调用的用于初始化的函数
    //如果不写 默认存在一个无参构造函数

    //构造函数的写法
    //1.没有返回值
    //2.函数名和类名必须相同
    //3.没有特殊要求时 一般都是public的
    class Person
    {
        public string name;
        public int age;
        //类中是允许自己声明无参构造函数
        //结构体不允许
        public Person()
        {
            name = "周健";
            age = 18;
        }

        public Person(int age)
        {
            //this代表当前调用该函数的对象自己
            this.age = age;
        }
        public Person(string name, int age) : this(age + 10)
        {
            //this.name = name;
            //this.age = age;
            Console.WriteLine("Person两个参数构造函数的调用");
        }

        //当引用类型的堆内存被回收时，会调用该函数
        //析构函数 是当垃圾 真正被回收的时候 才会调用的函数
        ~Person()
        {

        }
    }

    //4.构造函数可以被重载
    //5.this代表当前调用该函数的对象自己

    //注意
    //如果不自己实现无参构造函数而实现有参构造函数
    //会失去原有的默认的无参构造函数
    #endregion

    #region 知识点二 构造函数特殊写法
    //可以通过this 重用构造函数代码
    //访问修饰符 构造函数名(参数列表):this.(参数1，参数2....)
    #endregion

    #region 知识点三 析构函数
    //基本概念
    //当引用类型的堆内存被回收时，会调用该函数
    //对于需要手动管理内存的语言（比如C++），需要在析构函数中做一些内存回收处理
    //但是c#中存在自动垃圾回收机制GC
    //所有我们几乎不会怎么使用析构函数，除非你想在某一个对象被垃圾回收时，做一些特殊处理
    //注意：
    //在Unity开发中析构函数几乎不会使用，所以该知识点只做了解即可

    //基本语法
    //~类名()
    //{

    //}
    #endregion

    #region 知识点四 垃圾回收机制
    //垃圾回收，引文简写GC(Garbage Collector)
    //垃圾回收的过程是在遍历(Heap)上动态分配的所有对象
    //通过识别他们是否被引用来确定哪些对象是垃圾，哪些对象仍要被使用
    //所谓的垃圾回收就是没有 被 任何变量，对象引用的内容
    //垃圾就需要被回收释放

    //垃圾回收有很多种算法，比如
    //引用计数(Reference Counting)
    //标记清除(Mark Sweep)
    //标记整理(Mark Compact)
    //复制集合(Copy Collection)

    //注意;
    //GC只负责堆(Heap)内存的垃圾回收
    //引用类型都是存在堆(Heap)中，所以它的分配和释放都通过垃圾回收机制来整理

    //栈(Stack)上的内存是由系统自动管理的
    //值类型在栈(Stack)中分配内存的，他们有自己的生命周期，不用对他们进行管理，会自动分配和释放

    //C#中内存回收机制的大概原理
    //0代内存 1代内存 2代内存
    //代的概念;
    //代是垃圾回收机制使用的一种算法 (分代算法)
    //新分配的对象都会被配置在第0代内存中
    //每次分配都可能会进行垃圾回收以释放内存(0代内存满时)

    //在一次内存回收过程开始时，垃圾回收器会认为堆中全是垃圾，会进行一下两步
    //1.标记对象 从根(静态字段、方法参数)开始检查引用对象，标记后为可达对象，未标记为不可达对象
    //  不可达对象就认为是垃圾
    //2.搬迁对象压缩堆 （挂起执行托管代码线程） 释放未标记的对象 搬迁可达对象 修改引用地址

    //大对象总被认为是第二代内存 目的是减少性能损耗，提高性能
    //不会对大对象进行搬迁压缩 85000字节（83kb) 以上的对象为大对象

    #endregion

    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Lesson4_封装_构造函数和析构函数");

            Person p = new Person();
            Console.WriteLine(p.age);

            Person p1 = new Person("xxx", 18);
            //手动触发垃圾回收的方法
            //一般情况下 我们不会频繁调用
            //都是在 Loading过场景时 才会调用
            GC.Collect();
        }

        //总结
        //构造函数
        //实例化对象时 调用的函数
        //主要是用来初始化变量的

        //基本语法
        //不写返回值
        //函数名和类名相同
        //访问修饰符根据需求而定
        //一般是pubilc

        //注意
        //可以重载构造函数
        //可以用this语法重用代码
        //可以在函数中用this区分同名参数和成员变量
        //有参构造会顶掉默认的无参构造

        //析构函数
        //当对被垃圾回收时 调用的 ，主要用于来回收资源或者特殊处理内存的

        //基本语法
        //不写返回值
        //不写修饰符
        //不能有参数
        //函数名和类名相同
        //前面加~
    }
}
